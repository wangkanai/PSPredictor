name: Publish to NuGet

on:
  push:
    tags:
      - 'v*.*.*'
      - 'v*.*.*-*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (e.g., 2.0.0-alpha.1)'
        required: true
        type: string
      nuget_source:
        description: 'NuGet source'
        required: false
        default: 'https://api.nuget.org/v3/index.json'
        type: choice
        options:
          - 'https://api.nuget.org/v3/index.json'
          - 'https://pkgs.dev.azure.com/wangkanai/_packaging/wangkanai/nuget/v3/index.json'

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  validate-version:
    name: Validate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract-version.outputs.version }}
      is-prerelease: ${{ steps.extract-version.outputs.is-prerelease }}
    
    steps:
    - name: Extract version from tag or input
      id: extract-version
      run: |
        if [ "${{ github.event_name }}" == "push" ]; then
          # Extract version from tag (remove 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
        else
          # Use manual input
          VERSION="${{ github.event.inputs.version }}"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        
        # Check if it's a prerelease (contains -, alpha, beta, rc, etc.)
        if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
          if [[ "$VERSION" =~ - ]]; then
            echo "is-prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is-prerelease=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ùå Invalid version format: $VERSION"
          exit 1
        fi
        
        echo "üì¶ Publishing version: $VERSION"
        echo "üè∑Ô∏è Is prerelease: $([ "$VERSION" =~ - ] && echo "true" || echo "false")"

  build-and-publish:
    name: Build and Publish
    runs-on: windows-latest
    needs: validate-version
    environment: 
      name: ${{ needs.validate-version.outputs.is-prerelease == 'true' && 'prerelease' || 'production' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        global-json-file: global.json

    - name: Update version in Directory.Build.props
      run: |
        $version = "${{ needs.validate-version.outputs.version }}"
        $buildPropsPath = "Directory.Build.props"
        $content = Get-Content $buildPropsPath -Raw
        $updatedContent = $content -replace '<Version>.*</Version>', "<Version>$version</Version>"
        Set-Content $buildPropsPath $updatedContent -NoNewline
        Write-Host "‚úÖ Updated version to: $version"
      shell: pwsh

    - name: Restore dependencies
      run: dotnet restore --verbosity minimal

    - name: Build solution (Release)
      run: dotnet build --configuration Release --no-restore --verbosity minimal

    - name: Run core tests
      run: |
        dotnet test tests/Unit/PSPredictor.Tests.csproj `
          --configuration Release `
          --no-build `
          --verbosity minimal `
          --logger "console;verbosity=minimal"

        dotnet test tests/Core.Tests/PSPredictor.Core.Tests.csproj `
          --configuration Release `
          --no-build `
          --verbosity minimal `
          --logger "console;verbosity=minimal"
      shell: pwsh

    - name: Test module loading
      run: |
        $modulePath = "./src/PSPredictor/bin/Release/net9.0/PSPredictor.dll"
        if (Test-Path $modulePath) {
          Write-Host "‚úÖ Module found at: $modulePath"
          try {
            Import-Module $modulePath -Force -ErrorAction Stop
            Write-Host "‚úÖ Module loaded successfully"
            
            # Test basic cmdlets exist
            $commands = @(
              'Get-PSPredictorStatus',
              'Set-PSPredictorMode',
              'Install-PSPredictor'
            )
            
            foreach ($cmd in $commands) {
              $cmdlet = Get-Command $cmd -ErrorAction SilentlyContinue
              if ($cmdlet) {
                Write-Host "‚úÖ $cmd cmdlet available"
              } else {
                Write-Host "‚ùå $cmd cmdlet not found"
                throw "$cmd cmdlet not found"
              }
            }
          } catch {
            Write-Host "‚ùå Failed to load or test module: $_"
            exit 1
          }
        } else {
          Write-Host "‚ùå Module not found at expected path: $modulePath"
          exit 1
        }
      shell: pwsh

    - name: Create NuGet packages
      run: |
        dotnet pack src/PSPredictor/PSPredictor.csproj `
          --configuration Release `
          --no-build `
          --verbosity minimal `
          --output ./packages `
          -p:IncludeSymbols=true `
          -p:SymbolPackageFormat=snupkg
      shell: pwsh

    - name: Publish to NuGet
      run: |
        $apiKey = "${{ secrets.NUGET_API_KEY }}"
        $source = "${{ github.event.inputs.nuget_source || 'https://api.nuget.org/v3/index.json' }}"
        
        if ([string]::IsNullOrEmpty($apiKey)) {
          Write-Host "‚ùå NUGET_API_KEY secret not found"
          exit 1
        }
        
        Write-Host "üöÄ Publishing to: $source"
        
        # Publish main package
        $package = Get-ChildItem ./packages -Filter "PSPredictor.*.nupkg" | Where-Object { $_.Name -notlike "*symbols*" } | Select-Object -First 1
        if ($package) {
          Write-Host "üì¶ Publishing: $($package.Name)"
          dotnet nuget push $package.FullName --api-key $apiKey --source $source --skip-duplicate
          
          # Publish symbols package if it exists
          $symbolsPackage = Get-ChildItem ./packages -Filter "PSPredictor.*.snupkg" | Select-Object -First 1
          if ($symbolsPackage) {
            Write-Host "üîç Publishing symbols: $($symbolsPackage.Name)"
            dotnet nuget push $symbolsPackage.FullName --api-key $apiKey --source $source --skip-duplicate
          }
        } else {
          Write-Host "‚ùå No package found to publish"
          exit 1
        }
      shell: pwsh
      env:
        NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}

    - name: Create GitHub Release
      if: github.event_name == 'push'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: PSPredictor ${{ needs.validate-version.outputs.version }}
        body: |
          ## PSPredictor ${{ needs.validate-version.outputs.version }}
          
          üöÄ **C# Binary Module - Advanced PowerShell Command-Line Enhancement**
          
          ### üì¶ Installation
          ```powershell
          Install-Module PSPredictor -RequiredVersion ${{ needs.validate-version.outputs.version }}
          ```
          
          ### ‚ú® Key Features
          - **AI-Powered Predictions**: ML.NET integration with embedded models
          - **Advanced Editing**: Cmd/Emacs/Vi editing modes with customizable key bindings
          - **Real-time Syntax Highlighting**: PowerShell and CLI tool syntax coloring
          - **Intelligent Auto-completion**: 26+ CLI tools with context-aware suggestions
          - **Cross-platform Support**: Windows, Linux, and macOS compatibility
          - **Performance Optimized**: <100ms response time for predictions
          
          ### üîÑ Migration from v1.x
          This is a major version update with breaking changes. See migration guide in documentation.
          
          ### üìã Full Changelog
          See [CHANGELOG.md](https://github.com/wangkanai/PSPredictor/blob/main/CHANGELOG.md) for detailed changes.
          
          ### üìñ Documentation
          - [User Guide](https://github.com/wangkanai/PSPredictor/blob/main/docs/user-guide/)
          - [Architecture Documentation](https://github.com/wangkanai/PSPredictor/blob/main/docs/architecture/)
          - [API Reference](https://github.com/wangkanai/PSPredictor/blob/main/docs/api/)
        draft: false
        prerelease: ${{ needs.validate-version.outputs.is-prerelease == 'true' }}

    - name: Upload packages as artifacts
      uses: actions/upload-artifact@v4
      with:
        name: nuget-packages-${{ needs.validate-version.outputs.version }}
        path: ./packages/*.nupkg
        retention-days: 90

  publish-to-powershell-gallery:
    name: Publish to PowerShell Gallery
    runs-on: windows-latest
    needs: [validate-version, build-and-publish]
    if: success()
    environment: 
      name: ${{ needs.validate-version.outputs.is-prerelease == 'true' && 'prerelease' || 'production' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download packages
      uses: actions/download-artifact@v4
      with:
        name: nuget-packages-${{ needs.validate-version.outputs.version }}
        path: ./packages

    - name: Publish to PowerShell Gallery
      run: |
        $apiKey = "${{ secrets.POWERSHELL_GALLERY_API_KEY }}"
        
        if ([string]::IsNullOrEmpty($apiKey)) {
          Write-Host "‚ö†Ô∏è POWERSHELL_GALLERY_API_KEY not found, skipping PowerShell Gallery publish"
          exit 0
        }
        
        Write-Host "üöÄ Publishing to PowerShell Gallery"
        
        # Find the main package (not symbols)
        $package = Get-ChildItem ./packages -Filter "PSPredictor.*.nupkg" | Where-Object { $_.Name -notlike "*symbols*" } | Select-Object -First 1
        
        if ($package) {
          Write-Host "üì¶ Publishing: $($package.Name)"
          Publish-Module -Path $package.FullName -NuGetApiKey $apiKey -Repository PSGallery -Force
        } else {
          Write-Host "‚ùå No package found to publish to PowerShell Gallery"
          exit 1
        }
      shell: pwsh
      env:
        POWERSHELL_GALLERY_API_KEY: ${{ secrets.POWERSHELL_GALLERY_API_KEY }}